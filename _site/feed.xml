<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-03-09T11:11:44-05:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Amit Panghal</title><subtitle>Student @NYU Courant | IIT Bombay | Distributed Systems | Security | Applied Cryptography | Blockchain</subtitle><entry><title type="html">Whatsapp’s E2E Encryption: How does it work in practice?</title><link href="http://localhost:4000/e2e_whatsapp/" rel="alternate" type="text/html" title="Whatsapp's E2E Encryption: How does it work in practice?" /><published>2018-10-06T00:00:00-04:00</published><updated>2018-10-06T00:00:00-04:00</updated><id>http://localhost:4000/e2e_whatsapp</id><content type="html" xml:base="http://localhost:4000/e2e_whatsapp/">&lt;p&gt;You must have heard about WhatsApp using end to end encryption. In layman’s words, every message that you sent to your friend, is encrypted on your device, this encrypted message passes through network and bunch of servers and reaches your friend’s device, and finally it is decrypted on friend’s device. So as long as underlying cryptography is intact, you can be assured that no one else other than your friend knows about your &lt;a href=&quot;https://www.youtube.com/watch?v=gPDcwjJ8pLg&quot;&gt;dirty little secret&lt;/a&gt;. Is it as simple as it sounds?, No. Purpose of this post is to give you peak  of what is actually happening behind the scene.&lt;/p&gt;

&lt;h2 id=&quot;features-for-a-secure-messaging-system&quot;&gt;Features for a secure messaging system&lt;/h2&gt;

&lt;p&gt;So what possible features such system should have? I will introduce a few characters in the system. I will chose Ankita, Bud and Mayank. (Cryptography literature uses Alice, Bob and Mallory. Name are chosen based on their roles). Ankita and Bud wants to exchange messages. Mayank is evil, and he wants to listen on the conversation between Ankita and Bud, and possibly want to send messages to Ankita acting as Bud and to Bud acting as Ankita. We want to our system to have following properties:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Confidentiality : Mayank can’t know what messages Ankita and Bud send to each other.&lt;/li&gt;
  &lt;li&gt;Integrity : If Bud receives a message from Ankita, He can check if the message was modified by Mayank on the way.&lt;/li&gt;
  &lt;li&gt;Authenticity : When Bud receives a message from Ankita, He can be sure it is from Ankita and not from Mayank.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Another feature that we might want is ‘deniability’, that is if someone recovers, Ankita’s or Bob’s old messages in future, it can’t be linked to them and they can deny having send that message.&lt;/p&gt;

&lt;p&gt;1) could be achieved using encryption/decryption mechanism. 2) and 3) could be achieved through MACs and Digital Signatures. These primitives require secure exchange of some secret (In case of Symmetric Key Cryptography) or establishment of each other’s public information (case of public key cryptography). Public Key Cryptography is nice in sense that you dont need to share a secret with someone you want to send message to, as long you know each other’s public key or (identity). Problem with that approach is that Ankita need to be assured that she actually has Bud’s public key and its not of Mayank’s and so She can securely communicate with Bud by encrypting the messages with Bud’s public key. Only Bud, who has the corresponding private key can decrypt the message. Similarly , In case of symmetric key cryptography, Mayank and Ankita need a mechanism to share the secret (May be meet in person and exchange), which they will use for encryption/decryption. In former case, it is okay if Mayank learns about Ankita and Bud’s public key (It’s Public).&lt;/p&gt;

&lt;h2 id=&quot;whatsapp-e2e-encryption-protocol&quot;&gt;WhatsApp E2E Encryption protocol?&lt;/h2&gt;

&lt;p&gt;Whatsapp uses open source &lt;a href=&quot;https://en.wikipedia.org/wiki/Signal_Protocol&quot;&gt;Signal Protocol&lt;/a&gt; developed by &lt;a href=&quot;https://signal.org&quot;&gt;‘Open Whisper Systems’&lt;/a&gt; (They have their own messaging application, Signal). Signal Protocol uses primitives like &lt;a href=&quot;https://en.wikipedia.org/wiki/Double_Ratchet_Algorithm&quot;&gt;Double Ratchet Algorithm&lt;/a&gt;, prekeys, Triple &lt;a href=&quot;https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange&quot;&gt;Diffie Hellman&lt;/a&gt; Handshake, &lt;a href=&quot;https://en.wikipedia.org/wiki/Curve25519&quot;&gt;Curve25519&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Advanced_Encryption_Standard&quot;&gt;AES&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/HMAC&quot;&gt;HMAC_SHA256&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We will define these primitive before putting them all together to understand Signal Protocol.&lt;/p&gt;

&lt;h2 id=&quot;understanding-primitives&quot;&gt;Understanding Primitives&lt;/h2&gt;

&lt;h3 id=&quot;prekeys&quot;&gt;Prekeys&lt;/h3&gt;
&lt;p&gt;These are Curve25519 key pairs generated on device during install time. There is one Signed Prekey Pair and several one time prekey pairs. The Identity Public key and the Public keys of the prekey pairs are signed by a long term Identity Secret Key(Curve25519 private key correspond to Identity public key) and sent to server during registeration. Server stores these keys along with Identity Public key.&lt;/p&gt;

&lt;h3 id=&quot;curve25519&quot;&gt;Curve25519&lt;/h3&gt;
&lt;p&gt;Elliptic curve used as part of Diffie Hellman Key Exchange Protocol. I will discuss Elliptic Curve Cryptography in separate post. Its security is based on difficulty of discrete logarithm problem in Large Finite Groups.&lt;/p&gt;

&lt;h3 id=&quot;diffie-hellman-key-agreement&quot;&gt;Diffie Hellman Key Agreement&lt;/h3&gt;
&lt;p&gt;Diffie Hellman Key Agreement or Triple Diffie Hellman Handshake allows two parties to have a shared secret over public channel (Mayank is able to listen to message exchanged by Ankita and Bud). It is based on arthmetic modulo large prime p and it basically works as follows,&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Ankita and Bud agree on protocol parameters, large prime p and generator g. ‘g’ is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Primitive_root_modulo_n&quot;&gt;generator&lt;/a&gt; of multiplicative group ‘modulo p’. Generator is between 1 and p-1 and has this nice property, that every element in [1, p] can be represented as ‘g^k mod p’ where k is in [0,p-2].&lt;/li&gt;
  &lt;li&gt;Ankita selects a random number ‘x’ between ‘1’ and ‘p-1’ , her private key.&lt;/li&gt;
  &lt;li&gt;Bud selects a random number ‘y’ between ‘1’ and ‘p-1’, his private key.&lt;/li&gt;
  &lt;li&gt;Ankita sends Bud, ‘x_p = g^x mod p’ , her public key.&lt;/li&gt;
  &lt;li&gt;Bud sends Ankita ‘y_p = g^x mod p’, his public key.&lt;/li&gt;
  &lt;li&gt;Ankita computes ‘ss_a = y_p^x mod p’&lt;/li&gt;
  &lt;li&gt;Bud computes ‘ss_b = x_p^y mod p’&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;After completion of protocol Ankita and Bud have a shared secret ‘ss_a = ss_b = g^(xy) mod p’ .&lt;/p&gt;

&lt;p&gt;Mayank on the network sees ‘x_p’ and ‘y_p’, and it is computationaly infeasible for him to determine shared secret without knowledge of ‘x’ or ‘y’ .
We assume here that Mayank only see the messages on channel between Bud and Ankita but doesnt temper them.&lt;/p&gt;

&lt;h3 id=&quot;extended-triple-diffie-hellman-key-agreement-x3dh&quot;&gt;Extended Triple Diffie Hellman Key Agreement (X3DH)&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;&amp;quot;https://signal.org/docs/specifications/x3dh/&amp;quot;&quot;&gt;X3DH&lt;/a&gt; is an extension of above protocol for asynchronous setting. Imagine Ankita wants to establish a shared key with Bud to send encrypted message to him. Above agreement works smoothly when Bud is online. What if Bud is offline?. She would have to wait for Bob to come online. 
Also, In above key agreement, Ankita and Bud have no way to determine if they are talking to each other. They may be both talking to Mayank thinking they are talking to each other. The protocol might end up as Ankita and Mayank sharing a secret, Mayank and Bud agreeing on a key. 
X3DH solves both these problems using a trusted third party and Prekeys. Ankita and Bud register signed prekeys (Signed using their long term private keys) on a trusted server. Each time one of them one wants to establish a shared secret with other, the former fetches the signed prekey bundle of latter. Lets assume Ankita is sender.&lt;/p&gt;

&lt;p&gt;Now, Ankita does her part, performs DH Operation (raising a public key with a private key, operation 5 in above) 3 or 4 times (depending on prekey she fetched from server). These operations are between,&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Ankita’s long term private key and Bud’s signed prekey.&lt;/li&gt;
  &lt;li&gt;Ankita’s ephemeral private key (from key pair generated specifically for this exchnage and deleted afterwards) and Bud’s signed prekey.&lt;/li&gt;
  &lt;li&gt;Ankita’s ephemeral private key and Bud’s long term public key.&lt;/li&gt;
  &lt;li&gt;(if prekey bundle  has a one time public key) Ankita’s ephemeral private key and Bud’s One time public key.&lt;/li&gt;
&lt;/ol&gt;
&lt;figure&gt;
    &lt;a&gt;&lt;img src=&quot;/assets/img/X3DH.png&quot; /&gt;&lt;/a&gt;
    &lt;figcaption&gt;X3DH&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;The outputs from above steps are combined used as a key material i.e. master secret. These keys derived from master secret are used in Double Ratchet decribed below  to send subsequent encrypted messages to Bud, all of them include Ankita’s ephemeral public key, long term identity key and information on which of the Bud’s one time public key is used ( in case it is in step 4.)are included in header (plaintext). This ends x3dh from Ankita’s side. The messages received by Bud if he is online or can be stored on server where Bud can fetch it later. When Bud receives the message later, he can derive the same master secret by using his private keys and Ankita’s public keys in the message header. 
This schemes allows Ankita and Bud to authenticate each other and derive shared secret to be used as key material.&lt;/p&gt;

&lt;h3 id=&quot;hmac_sha256&quot;&gt;HMAC_SHA256&lt;/h3&gt;
&lt;p&gt;It is keyed cryptographic hash function. Apart from the value to be hashed, this function also takes input a key. Unlike hash function which are easy to compute for a given input, keyed hash function require knowledge of the key. Here it is used as a key derivation function and MAC.&lt;/p&gt;

&lt;h3 id=&quot;double-ratchet&quot;&gt;Double Ratchet&lt;/h3&gt;
&lt;p&gt;‘Ratchet’ is name of a device that moves only in one direction. Double Ratchet uses two cryptographic Ratchets, i.e., deriving new keys from current keys and moving forward, while forgetting old keys. The two Ratchets used are Diffie-Hellman ratchet and symmetric ratchet. Each time a Diffie Hellman ratchet move forward, a secret is established between sender and receiver using Diffie Hellman described above, and the secret is used to derive two new keys (root key and chain key).  Symmetric Ratchet moves forward by using a  Key Derivation Function using chain key to generate a message key to encrypt message to be sent, and a chain key to be used for next ratchet movement. This ‘Ratcheting’ provides a useful property to protocol known as forward secrecy, i.e, if Ankita or Bud comprise their keys in future, their previous messages cant be comprised (decrypted), as long as ratchet works as expected (old keys are deleted).&lt;/p&gt;

&lt;h2 id=&quot;putting-everything-together&quot;&gt;Putting Everything Together&lt;/h2&gt;

&lt;p&gt;I have attempted to summarize the primitives used in the protocol which could be difficult to digest all at once. Assuming the primitives work as expected, following steps will describe the working of protocol in much simpler language.  These steps occur when Ankita wants to send message to Bud using Whatsapp,&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Registeration of Clients with whatsapp server (Mobile apps on Ankita’s and Bud’s phone). It includes registering signed prekeys.&lt;/li&gt;
  &lt;li&gt;Session setup by Ankita using x3dh&lt;/li&gt;
  &lt;li&gt;In step 2, Ankita calculates master secret and Using DH Ratchet step, derives  a root key and a chain key to be used Symmetric Ratchet.&lt;/li&gt;
  &lt;li&gt;Ankita derives a message key and next chain key using the chain key using  symmetric Ratchet.&lt;/li&gt;
  &lt;li&gt;She encrypts her message using message key ( &lt;a href=&quot;https://en.wikipedia.org/wiki/Advanced_Encryption_Standard&quot;&gt;AES256 in CBC mode&lt;/a&gt; ).&lt;/li&gt;
  &lt;li&gt;Everytime she sends a message her Symmetric Ratchet moves forward.&lt;/li&gt;
  &lt;li&gt;Everytime she receives a response from Bud, which includes a new public key in header, advances her DH Ratchet, calculates a new root key and a new chain key.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;On Bud’s side,&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;When he retrives first message from Ankita, he completes the session setup by deriving the master secret, root key, chain key and the message key.&lt;/li&gt;
  &lt;li&gt;Uses messages key to decrypt.&lt;/li&gt;
  &lt;li&gt;If he wants to send message, he generates a new ephemeral pair, moves his DH ratchet forward using the root key and ephemeral private key and replaces hi chain key and message key.&lt;/li&gt;
  &lt;li&gt;New message is derived from chain key and message is encrypted.&lt;/li&gt;
  &lt;li&gt;encrypted message is sent with Bud’s ephemeral key in header.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In the image below (Assuming it’s Ankita’s Phone), message in white boxes are one received and greens one are one sent. Each pair of continous boxes can help you visualize ratchet movements.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;White -&amp;gt; White :  Symmteric Ratchet of Bud moves forward by 1 step (new message key and next chain keys are derived)&lt;/li&gt;
  &lt;li&gt;Green -&amp;gt; Green : Symmetric Ratchet of Ankita moves forward by 1 step (she derives new message key and chain key)&lt;/li&gt;
  &lt;li&gt;White -&amp;gt; Green : Ankita’s DH Ratchet moves forward by 1 step(she derives new root key and chain key)&lt;/li&gt;
  &lt;li&gt;Green -&amp;gt; White : Bud’s DH Ratchet moves 1 step forwards (He derives new root key and chain key)&lt;/li&gt;
&lt;/ol&gt;

&lt;figure&gt;
    &lt;a&gt;&lt;img src=&quot;/assets/img/conv.png&quot; /&gt;&lt;/a&gt;
    &lt;figcaption&gt;Screenshot of Ankita's Phone&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h3 id=&quot;media-attachements-and-files&quot;&gt;Media Attachements and Files&lt;/h3&gt;
&lt;p&gt;Media files are encrypted and uploaded to blob store. When Ankita sends an image or video to Bud, the pointer to the location of encrypted image or video file in blob store is encrypted and  sent using above scheme.&lt;/p&gt;

&lt;h3 id=&quot;group-messages&quot;&gt;Group Messages&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;Whenever a group member sends his/her 1st message, he/she generates a sender key which is distributed to all group members using one-to-one protcol described above.&lt;/li&gt;
  &lt;li&gt;For subsequent messages, messages are encrypted using new message key derived by symmetric Ratchet (this is different from one used in one-to-one).&lt;/li&gt;
  &lt;li&gt;Since every member has other member’s sender key, they can move ratchet corresponding to sender to decrypt their messages.&lt;/li&gt;
  &lt;li&gt;Whenever a member leaves the group, sender keys are renegotiated (step 1).&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;calling&quot;&gt;Calling&lt;/h3&gt;
&lt;p&gt;Calling is synchronous/real-time. Whenever Ankita  calls bud, she generates a random &lt;a href=&quot;https://en.wikipedia.org/wiki/Secure_Real-time_Transport_Protocol&quot;&gt;SRTP&lt;/a&gt; secret.
This secret is send to Bud using pairwise system. If he responds to call, encrypted session begins.&lt;/p&gt;

&lt;h3 id=&quot;miscellaneous&quot;&gt;Miscellaneous&lt;/h3&gt;
&lt;p&gt;Apart from the end to end encryption, the the channel between the whatsapp client and whatsapp server is secure. Plaintext Headers are not visible to anyone listing on channels. This is server’s extra wrapping over Ankita’s already wrapped gift(message) to Bud.&lt;/p&gt;

&lt;h2 id=&quot;wrapping-up&quot;&gt;Wrapping Up&lt;/h2&gt;
&lt;p&gt;So you might have heard people saying that Whatsapp is probably reading our messages, As you happen to see ads of things on your facebook feed which you happen to discuss on whatsapp chats. Lets cover some possibilities and conspiracy theories.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;If you trust that whatsapp’s end to end encryption is actually implemented as per signal specification, then no way they are able to read your chats. Unlike Signal application, whatsapp’s code is not open source so you can’t really confirm.&lt;/li&gt;
  &lt;li&gt;Assuming signal protocol is implemented correctly, whatsapp servers know which whatsapp user is interacting with which user, how frequently, how recently. Same is true for signal app’s servers. If you have phone mobile registered on facebook and is the one use for whatsapp. They could use this information to associate your friend’s activity on facebook and serve you relevant ad which might come as surprise to you.&lt;/li&gt;
  &lt;li&gt;They might have enough information from other channels and such an ad is merely an coincidence.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;references-and-recommended-readings&quot;&gt;References and Recommended Readings&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;Signal Developer &lt;a href=&quot;https://signal.org/docs/&quot;&gt;Docs&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Signal &lt;a href=&quot;https://signal.org/blog/&quot;&gt;Blogs&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Whatsapp &lt;a href=&quot;https://www.whatsapp.com/security/WhatsApp-Security-Whitepaper.pdf&quot;&gt;whitepaper&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Diffie Hellman simple &lt;a href=&quot;https://www.youtube.com/watch?v=YEBfamv-_do&amp;amp;feature=youtu.be&quot;&gt;explanation&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Off the record messaging, &lt;a href=&quot;https://en.wikipedia.org/wiki/Off-the-Record_Messaging&quot;&gt;OTR&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="whatsapp" /><category term="Signal Protocol" /><category term="cryptography" /><category term="security" /><summary type="html">How does signal protocol work?</summary></entry><entry><title type="html">Demystifying Authentication</title><link href="http://localhost:4000/demystifying-authentication/" rel="alternate" type="text/html" title="Demystifying Authentication" /><published>2018-09-24T00:00:00-04:00</published><updated>2018-09-24T00:00:00-04:00</updated><id>http://localhost:4000/demystifying-authentication</id><content type="html" xml:base="http://localhost:4000/demystifying-authentication/">&lt;h2 id=&quot;notes-on-authentication&quot;&gt;Notes on authentication&lt;/h2&gt;

&lt;p&gt;Authentication is a mechanism to guarantee that entities are who they claim they are, or that the information has not been modified by unauthorized parties. In this post I am talking about entity authentication which is also referred to as identification. Entity authentication techniques assures one party through acquisition of corroborative evidence, of both the identity of a second party involved, and that the second was active at the time evidence was created or acquired. For example, when you are trying to access your bank account online through your bank’s website, You are asked to enter login credentials, your username and password, or may be some other information say some numbers on your credit/debit card. Bank identifies you through the credentials and this particular type of authentication is unilateral authentication where Bank is trying to identify you in order to give access to their services. Another simple example is you talking to your friend on phone, you and your friend identify each other through voice recognition. It is an example of Mutual Authentication.&lt;/p&gt;

&lt;p&gt;Any such protocol between two parties say Alice and Bob should achieve following objectives:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Alice is able to successfully authenticate herself to Bob, and Bob at the end of protocol accepts Alice’s Identity.&lt;/li&gt;
  &lt;li&gt;Bob should not be able to use the exchange with Alice, to successfully impersonate Alice to an another party Carol.&lt;/li&gt;
  &lt;li&gt;Mallory should not be able to identify herself as Alice to Bob. The probability that this happens should be negligible.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Entity Authentication can be majorly divided into three categories:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Something You Know&lt;/strong&gt; (Knowledge Based): These include knowledge of a secret. The secret could be standard passwords, personal identification numbers (PINs) and the secret or private keys whose knowledge is demonstrated in challenge-response protocols.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Something You Own&lt;/strong&gt; (ownership): These could be the physical accesories that one might own. for example, magnetic stripe and chip cards, your smartphone, tamper resistant hardware storing key etc.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Something You Are&lt;/strong&gt; : This includes methods which make use of physical human characteristics and biometrics, such as handwritten signatures, fingerprints, voice, retina patterns, and even dynamic keyboarding characteristics.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Entity Authentication is generally used to facilitate access control to a resource or a service, where access privilege is linked to a particular identity. Most common method that is used is password based (belongs to 1st category) and also referred to as weak authentication. The password usually serves a shared secret between user and system. The way information about password is stored on the on the system, and how it is used later to verify the password entered by user determines the possible attacks on the scheme. The Most common way is to store &lt;a href=&quot;https://en.wikipedia.org/wiki/Cryptographic_hash_function&quot;&gt;cryptographic hash&lt;/a&gt; of salted password along with the salt.
The ‘salting of password’ means using adding a fixed size random &lt;a href=&quot;https://en.wikipedia.org/wiki/Cryptographic_nonce&quot;&gt;nonce&lt;/a&gt; to password. Salting makes &lt;a href=&quot;https://en.wikipedia.org/wiki/Dictionary_attack&quot;&gt;dictionary based attacks&lt;/a&gt; harder. What does it mean? Lets say salt is of size 12 bits, so an attacker creating offline dictionary attack would have store all 4096 possible variants of a single guess. If it is remote authentication, passwords are sent in cleartext over a secure channel. If channel is unsecure such schemes are also susceptible to replay attacks (even if you hash and send your password), where adversary learns about hash or cleartext when it is in transit and can use for future authentication. Passwords normally used are sequence of characters with additional minimum requirements placed by server for its strength. But users tend to set passwords with low entropy and hence are easy to guess. Check this &lt;a href=&quot;http://www.jbonneau.com/doc/B12-IEEESP-analyzing_70M_anonymized_passwords.pdf&quot;&gt;paper&lt;/a&gt; from Prof. Bonneau which analyzes millions of passwords used by yahoo users anonymously and proposes several guessing heuristics. 
A better approach is to use passphrases which are easy to remember and have higher entropy than random strings of fixed length.&lt;/p&gt;
&lt;figure&gt;
    &lt;a href=&quot;https://imgs.xkcd.com/comics/password_strength.png&quot;&gt;&lt;img src=&quot;https://imgs.xkcd.com/comics/password_strength.png&quot; /&gt;&lt;/a&gt;
    &lt;figcaption&gt;on password strength&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h2 id=&quot;one-time-passwords&quot;&gt;One Time Passwords&lt;/h2&gt;
&lt;p&gt;One Time Passwords provide timeliness guarantees which help authentication protocols to counter replay attacks. These protocols use one of following time variant parameters.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Random Numbers: used in challenge-response type authentication protocols where one party sends a newly generated nonce to other party and subsequent message are bound to this nonce. This demands for parties to store nonce during one instance of protocol execution&lt;/li&gt;
  &lt;li&gt;Sequence Numbers: This requires parties to maintain state and state is incremented with every execution.&lt;/li&gt;
  &lt;li&gt;Timestamps : Timestamps are included along with messages and messages that are not within a minimum threshold of local clock are discarded. This assume client and server clocks are synchronized and is vulnerable to adversarial resetting of clocks.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In practice, One Time Passwords are used along with other password based (weak authentication) techniques, to confirm User’s ownership of a device (a smartphone). This is most common 2FA (2 Factor) authentication in practice, out of band 2 factor authentication. The one time password generated at server is distributed to user’s registered devices. It could be done by a phone call or SMS. SMS based methods have deprecated and has been discouraged to use by NIST as of June 2016. It is due to ability of SMSs to be intercepted at a large scale.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Time-based_One-time_Password_algorithm&quot;&gt;TOTP&lt;/a&gt; uses both timestamps and sequence numbers, is used in &lt;a href=&quot;https://github.com/google/google-authenticator&quot;&gt;Google Authenticator&lt;/a&gt;, &lt;a href=&quot;https://authy.com/&quot;&gt;Authy&lt;/a&gt; and as part of 2 step verification in most of the web services.&lt;/p&gt;

&lt;p&gt;TOTP allows for users to generate one time passwords locally on their smartphone without network using TOTP applications.  For TOTP, you have one time set up phase and authentications. During set up, user registers with server, and server generates a secret which could be entered on TOTP application on smartphone. After this initial steup, you could just use otps generated on your device to login to server.&lt;/p&gt;

&lt;h2 id=&quot;strong-authentication&quot;&gt;Strong Authentication&lt;/h2&gt;
&lt;p&gt;Cryptographic Challenge Response based protocol typically fall under this category. The general idea is to enable Prover to prove his knowledge of the secret without revealing the secret itself to the verifier during protocol. This is done by providing a response to time variant challenge, this response is depends both on prover’s secret and the challenge. Someone listening on the link between prover and verifier would not be able to use it for subsequent authentication as each time there would be a different challenge.
Challenge response protocols are based on Symmetric key techniques, Public-key techniques and zero knowledge based.
&lt;strong&gt;Symmetric Key&lt;/strong&gt; based techniques rely on secure exchanges of keys and secrecy of keys. There are different implementations based on different kind of time variant parameters as challenges. Usually involved encryption/decryption or keyed hashing of challenge strings.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Public Key&lt;/strong&gt; based techniques involve either decryption of challenge encrypted by public key or digitally signing of challenges to prove knowledge of the private key.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Zero Knowledge Authentication&lt;/strong&gt; based protocols provide Prover ability to prove his knowledge of secret key to verifier without revealing any information about key in the process. These protocols use three steps. In step one, prover commits to a value by sending a commitment to verifier. Verifier sends a challenge to prover. Prover responds to the challenge using the secret and the value he commited in step 1. Finally, verifier check if response is valid by using commitment and Prover’s public information.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://fidoalliance.org/fido2/&quot;&gt;FIDO&lt;/a&gt; publishes standards for web services to use strong authentication. They encourage using public key based challenge response with an additional factor. Google’s security key(tamper resistant usb key device) is compliant with fido standard. The typical flow is&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;User registers on FIDO compliant web service (bank website), which prompts user to insert usb key and press a button.&lt;/li&gt;
  &lt;li&gt;New key pairs are generated locally, private key is on usb key and public key is registered on bank website.&lt;/li&gt;
  &lt;li&gt;Assuming browsers are FIDO Compliant, when accessing the website, a call is made which is same for all browser, which prompts user to use usb key.&lt;/li&gt;
  &lt;li&gt;Response is generated locally using the private key and send to website.&lt;/li&gt;
  &lt;li&gt;User can access the service if response is valid.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Instead of hardware usb key, other second factor devices say smartphone could be used. Keys could be stored locally on device and can be unlocked by binding device to user by using a another layer, say fingerprint scanner (biometrics) to unlock keys locally and send the response to desktop via bluetooth or NFC.&lt;/p&gt;

&lt;p&gt;While this looks good, (No typing/remembering passwords) and safe against passowrd phishing, but is still susceptible to session hijacking (Once the user has logged in).&lt;/p&gt;

&lt;p&gt;Also, another kind of authentication that we havent talked about is called “Continuous Authentication”. It usually works by monitoring user behavior and access patterns during a session, and logging user out if unusual activity is detected. It is very difficult to get it right and contradicts usability if honest users are denied access.&lt;/p&gt;

&lt;p&gt;A very &lt;em&gt;critical vulnerability&lt;/em&gt; in the authentication systems is the recovery mechanism deployed when a honest user loses access to his/her credentials. Here is where tradeoff is made between usability and security. Key recovery mechanism are usually exploited by using &lt;strong&gt;social engineering&lt;/strong&gt; techniques. 
Security in practice follows ‘something is better than nothing’ and try to minimize the attack surface while ensuring usability.&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;Handbook of Applied Cryptography, Alfred J. Manezes, Paul C. van Oorschot, Scott A. Vanstone&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="Authentication" /><category term="Fido" /><category term="Authenticator" /><category term="Authy" /><category term="digital" /><category term="cryptography" /><category term="security" /><summary type="html">How good is MFA?</summary></entry><entry><title type="html">A brief history of e-currencies</title><link href="http://localhost:4000/A-brief-history-of-e-currencies/" rel="alternate" type="text/html" title="A brief history of e-currencies" /><published>2018-07-16T00:00:00-04:00</published><updated>2018-07-16T00:00:00-04:00</updated><id>http://localhost:4000/A-brief-history-of-e-currencies</id><content type="html" xml:base="http://localhost:4000/A-brief-history-of-e-currencies/">&lt;p&gt;This blog post is summary of more detailed chapters about the same topic in the &lt;a href=&quot;https://bitcoinbook.cs.princeton.edu/&quot;&gt;book&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;traditional-financial-systems&quot;&gt;Traditional Financial Systems&lt;/h2&gt;

&lt;h3 id=&quot;barter---cash---credit&quot;&gt;Barter -&amp;gt; Cash -&amp;gt; Credit&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Barter : difficult to make the coordination where everyone finds what he needs based on what he/she is willing to exchange&lt;/li&gt;
  &lt;li&gt;Credit Based System : Goods and Services are received in exchange of favour/promise. Receiving Party has a debt, which it needs to settle in future. No way to quantify the favour. Risk is introduced in the system.&lt;/li&gt;
  &lt;li&gt;Cash Based system : Goods and Services are received in exchange of Cash. Good and Services are quantified using cash. System need to bootstrapped with cash to work.&lt;/li&gt;
  &lt;li&gt;Cash+Credit : Cash is used to quantify debt/favour in credit based systems.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ideas-in-context-of-an-online-p2p-file-sharing-system&quot;&gt;Ideas in context of an online p2p file sharing system&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Addressing “Freeloaders”, downloading but not sharing files&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Mnet_(peer-to-peer_network)&quot;&gt;Mojonation&lt;/a&gt; and Karma, solves using virtual cash or karma, receive some cash on sending some file, and spend that cash upon receiving.&lt;/li&gt;
  &lt;li&gt;These are ancestors of current protocols like BitTorrent, Tahoe-LAFS&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Online payment systems existing today can be grouped into credit and cash based groups. While credit cards transactions account for majority of payments online.
How that works? Well, you send your credit card details to companies like Amazon and they send your details to system which includes and not limited to Banks, processors, credit card companies. Another architecture is similar to paypal, where there is an intermediatory between buyer and seller, buyer sends credit card details to intermediatory which approves the transaction, notifies seller. Intermediatory settles balances with seller at the end of the day. With this architecture you avoid a sending your credit card details to seller which could be a security risk. It could also improve privacy, if you dont have to give your identity to seller. Drawbacks are complexity and that seller and buyer must have same intermediatory. 
Early web of 90s when privacy concerns were high amount users, technologies involving intermediatories were of great interest. Let go through some of the early attempts.&lt;/p&gt;

&lt;h3 id=&quot;firstvirtual-1994&quot;&gt;FirstVirtual 1994&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;First company with virtual office, employees spread across country communicating over internet&lt;/li&gt;
  &lt;li&gt;Similar to paypal but communication using email&lt;/li&gt;
  &lt;li&gt;Buyer and seller both send transaction detail to intermediatory and bills customer and on confirmation, seller is notified&lt;/li&gt;
  &lt;li&gt;90 days to settle consumer dispute&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;set-architecture&quot;&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Secure_Electronic_Transaction&quot;&gt;SET&lt;/a&gt; ARCHITECTURE&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;You send your view of transactions encrypted to Seller&lt;/li&gt;
  &lt;li&gt;Seller Forwards encrypted view with its own view to an intermediatory&lt;/li&gt;
  &lt;li&gt;Intermediatory decrypts your view and verfies if both views are same and approves Transaction&lt;/li&gt;
  &lt;li&gt;Developed by VISA and Mastercard along with Tech giants during that time&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cybercash&quot;&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/CyberCash&quot;&gt;CYBERCASH&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Implemented SET Architecture for credit card processing&lt;/li&gt;
  &lt;li&gt;Also had a digital cash product, CyberCoin for micropayments&lt;/li&gt;
  &lt;li&gt;Upper cap of 10 dollars worth of CyberCoin&lt;/li&gt;
  &lt;li&gt;Was affected by y2k bug - lead to double billing&lt;/li&gt;
  &lt;li&gt;Bankrupt in 2001 and IP was acquired by VeriSign which was resold to Paypal&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Why SET didnt work ?&lt;/p&gt;

&lt;p&gt;Problem of certificates. All users, merchants had to get digital certificates from company like VeriSign which was inconvenient for users.&lt;/p&gt;

&lt;p&gt;Moving on from Credit to Cash. Cash offers additional advantages over credit :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Anonymity : Credit based systems are tied to banks and hence they can track your spendings&lt;/li&gt;
  &lt;li&gt;Offline Transactions&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;e-cash-systems&quot;&gt;E-cash systems&lt;/h2&gt;
&lt;p&gt;Consider this simple physical analogy of a cash system. I issue a piece of paper with my signature on it which says “Bearer of this note can redeem X dollars by presenting it to me”. If people trust that I will keep my promise and my signature is unforgeable, these papers can pass on as bank notes. Now lets assume that people can make perfect copies of these notes and it is difficult to distinguish between original and copy. They can make copies and pass on to different people. This is called double spending problem. 
How do we solve it?
Well we can use unique serial numbers i.e, I write unique number on the paper when I issue it and record it in my ledger. So when someone spends it, the receiver will call me and give the serial number and I will mark it as spent in my ledger. Receiver can later come to me and get new notes with unique serial number in exchange of spent ones. 
Do you see the problem with this? 
We lost the feature that cash offers, anonymity. I can keep track of all the places you are spending your money. Well how do we solve it then?&lt;/p&gt;

&lt;h3 id=&quot;chaums-proposal-and-further-improvements&quot;&gt;Chaum’s Proposal and Further Improvements&lt;/h3&gt;
&lt;p&gt;Chaum’s idea was to use &lt;a href=&quot;http://www.hit.bme.hu/~buttyan/courses/BMEVIHIM219/2009/Chaum.BlindSigForPayment.1982.PDF&quot;&gt;blind signatures&lt;/a&gt;. That is when I issue you note you choose a random number such that I cant see it and I sign it. Choosing a number such a way that it is highly unlikely that it has been picked before. This guarantees Anonymity and prevents double spending.&lt;/p&gt;

&lt;p&gt;Chaum with collaboration with other cryptographers Fiat and Naor came up with offline &lt;a href=&quot;https://link.springer.com/chapter/10.1007/0-387-34799-2_25&quot;&gt;e-cash&lt;/a&gt; scheme. This clever idea revolves around detecting double spending rather than protecting it. Which could be then followed by attempts to recover or punish the perpetrator. If you think about it, it is what traditional finance system do, i.e., if you write someone a personal cheque, they have no guarantee that money is in their account but they can come after you if cheque bounces. If such offline were widely adopted, double spending would be recognized as a crime.
Their scheme worked like this: every digital coin issued to you encodes your identity in way that no one except you can decode it, not even the bank. So every time you want to spend it, recipient ask you to decode a random subset of your encoding and they keep a record of it. This information alone doesnt reveal your identity but if you were to double spend it, both recepients can go to bank with their subset of decodings and bank can put these together to identify you and take actions accordingly. You cannot frame someone as double spender, i.e try to spend coin upon receipt without going to the bank. Because you wont be able to decode random subset upon request when you try to spend it.&lt;/p&gt;

&lt;h3 id=&quot;digicash&quot;&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/DigiCash&quot;&gt;Digicash&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;It is company that came out of Chaum-Fiat-Naor scheme founded by Chaum in 1989. The cash in the system was Ecash. It works the following way&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Clients are anonymous but Merchant’s aren’t. Merchants have to return coin to the bank as soon as they receive them.&lt;/li&gt;
  &lt;li&gt;Coins can’t be split, so banks issue different kind of denominations, for you to pay for exact amount  of a transactions.&lt;/li&gt;
  &lt;li&gt;You click on payment link, it takes you to digicash website which creates a reverse connection to your computer and starts digicash software on it. you apporve the transaction and send the money.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;why did it fail ?&lt;/p&gt;

&lt;p&gt;Banks and merchants didnt adopt it. since there werent many merchants that accepted e-cash, users didnt want it either. It also didnt support user-user transactions.&lt;/p&gt;

&lt;p&gt;Digicash also experimented with tamper resistant hardware to prevent double spending. Sort of chip card and a device which keep track of your balance which decreases when you spend and increases when load it with money. This counter was was very difficult to tamper with physically.&lt;/p&gt;

&lt;h3 id=&quot;mondex-system&quot;&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Mondex&quot;&gt;Mondex&lt;/a&gt; system&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;A smart card and a Wallet unit.&lt;/li&gt;
  &lt;li&gt;Either could be loaded with cash.&lt;/li&gt;
  &lt;li&gt;User-User swap happened using wallet, put money into wallet by insertng card and receiver put their card in the wallet and load money onto card.&lt;/li&gt;
  &lt;li&gt;Anonymous way to exchange digital cash.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Issues with Mondex : slow and clunky, and retailer hated having separate payment terminals&lt;/p&gt;

&lt;p&gt;However, the smart card technology prevailed. Not for preventing double spending but to be used as authentication mechanism. That is you know the pin associated with your account.&lt;/p&gt;

&lt;h2 id=&quot;minting-money-in-digital-systems&quot;&gt;Minting Money in digital systems&lt;/h2&gt;
&lt;p&gt;To create a free-floating digital currency which is likely to acquire real value, you need something which is scarce by design. This is why gold/diamonds have been used as a backing for money. 
In digital ecosystems, one way to achieve scarcity is by requiring to solve a computational puzzle that takes some time to crack to mint digital money.&lt;/p&gt;

&lt;h3 id=&quot;dwork-and-naor-scheme-1992&quot;&gt;&lt;a href=&quot;https://dl.acm.org/citation.cfm?id=705669&quot;&gt;Dwork and Naor Scheme&lt;/a&gt; (1992)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;solution to combat email spams&lt;/li&gt;
  &lt;li&gt;reuqires you to solve mini computational puzzles every time your sending an email&lt;/li&gt;
  &lt;li&gt;Heavy cost for spammer who is try to send million emails&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;hashcash-1997&quot;&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Hashcash&quot;&gt;Hashcash&lt;/a&gt; (1997)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Proposed by Adam Back&lt;/li&gt;
  &lt;li&gt;Puzzles specific to email: based on sender, receiver and content and time which makes it impossible for spammers to reuse puzzle solutions&lt;/li&gt;
  &lt;li&gt;Puzzle independence&lt;/li&gt;
  &lt;li&gt;difficulty adjustment by recipients&lt;/li&gt;
  &lt;li&gt;Bitcoin uses similar puzzles with minor variation&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Why Hashcash didnt catch on ?&lt;/p&gt;

&lt;p&gt;Email spams arent that big of a problem. Good spam filters in place today.&lt;/p&gt;

&lt;h2 id=&quot;secure-timestamping&quot;&gt;Secure Timestamping&lt;/h2&gt;
&lt;p&gt;The goal of timestamping is to give an approximate idea of when a document came into existense. It could convey the order in which they are created. The security property ensures the timestamps cant be changed after.
These were ideas that might have lead up to blockchain, ledger in which transaction are securely recorded.&lt;/p&gt;

&lt;h3 id=&quot;haber-and-stornettas-scheme&quot;&gt;Haber and Stornetta’s &lt;a href=&quot;https://www.anf.es/pdf/Haber_Stornetta.pdf&quot;&gt;scheme&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Timestamping service which receives the document to timestamp&lt;/li&gt;
  &lt;li&gt;Service creates a certificate by signing the document with current time and a link/pointer  to previous document.&lt;/li&gt;
  &lt;li&gt;Each document ensures integrity of the contents of Next one,&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Later proposals improve on efficiency by grouping documents in blocks and linking the blocks together in a chain. Within each block, link documents in a tree like structure. This data structure forms skeleton of Bitcoin’s blockchain.&lt;/p&gt;

&lt;h2 id=&quot;combining-computational-puzzles-and-secure-timestamping&quot;&gt;Combining computational puzzles and secure timestamping&lt;/h2&gt;

&lt;h3 id=&quot;b-money&quot;&gt;&lt;a href=&quot;http://www.weidai.com/bmoney.txt&quot;&gt;B-money&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Proposed by Wei Dai in 1998&lt;/li&gt;
  &lt;li&gt;Money is minted using hashcash like puzzles&lt;/li&gt;
  &lt;li&gt;Solutions include solution to previous solution i.e, new coin is linked to previously minted coin&lt;/li&gt;
  &lt;li&gt;p2p system with every node having its own ledger&lt;/li&gt;
  &lt;li&gt;Solution to puzzles is propogated and everyone increment solver’s balance in their ledger&lt;/li&gt;
  &lt;li&gt;Similarly transactions are propogated&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;bitgold&quot;&gt;&lt;a href=&quot;&quot;&gt;Bitgold&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Proposed by Nick Szabo in series of blog posts&lt;/li&gt;
  &lt;li&gt;Similar to b-money&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Both B-money and Bitgold doesnt reveal in detail about how to solve issues like resolving disagreements with ledger.&lt;/p&gt;

&lt;p&gt;In Next series of blogs, I will write about cyptographic methods, consensus algorithms used in bitcoin and other altcoins. I also plan to write some dev-friendly blog-posts for getting started with smart-contract on various platforms.&lt;/p&gt;</content><author><name></name></author><category term="cryptocurrencies" /><category term="bitcoin" /><category term="history" /><category term="bitcoinbook.cs.princeton.edu" /><summary type="html">Digital cash system attempts before bitcoin.</summary></entry></feed>