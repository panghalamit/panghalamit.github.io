<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-10-06T03:18:22-04:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Amit Panghal</title><subtitle>Student @NYU Courant | IIT Bombay | Distributed Systems | Security | Applied Cryptography | Blockchain</subtitle><entry><title type="html">Demystifying Authentication</title><link href="http://localhost:4000/demystifying-authentication/" rel="alternate" type="text/html" title="Demystifying Authentication" /><published>2018-09-24T00:00:00-04:00</published><updated>2018-09-24T00:00:00-04:00</updated><id>http://localhost:4000/demystifying-authentication</id><content type="html" xml:base="http://localhost:4000/demystifying-authentication/">&lt;h2 id=&quot;notes-on-authentication&quot;&gt;Notes on authentication&lt;/h2&gt;

&lt;p&gt;Authentication is a mechanism to guarantee that entities are who they claim they are, or that the information has not been modified by unauthorized parties. In this post I am talking about entity authentication which is also referred to as identification. Entity authentication techniques assures one party through acquisition of corroborative evidence, of both the identity of a second party involved, and that the second was active at the time evidence was created or acquired. For example, when you are trying to access your bank account online through your bank’s website, You are asked to enter login credentials, your username and password, or may be some other information say some numbers on your credit/debit card. Bank identifies you through the credentials and this particular type of authentication is unilateral authentication where Bank is trying to identify you in order to give access to their services. Another simple example is you talking to your friend on phone, you and your friend identify each other through voice recognition. It is an example of Mutual Authentication.&lt;/p&gt;

&lt;p&gt;Any such protocol between two parties say Alice and Bob should achieve following objectives:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Alice is able to successfully authenticate herself to Bob, and Bob at the end of protocol accepts Alice’s Identity.&lt;/li&gt;
  &lt;li&gt;Bob should not be able to use the exchange with Alice, to successfully impersonate Alice to an another party Carol.&lt;/li&gt;
  &lt;li&gt;Mallory should not be able to identify herself as Alice to Bob. The probability that this happens should be negligible.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Entity Authentication can be majorly divided into three categories:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Something You Know&lt;/strong&gt; (Knowledge Based): These include knowledge of a secret. The secret could be standard passwords, personal identification numbers (PINs) and the secret or private keys whose knowledge is demonstrated in challenge-response protocols.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Something You Own&lt;/strong&gt; (ownership): These could be the physical accesories that one might own. for example, magnetic stripe and chip cards, your smartphone, tamper resistant hardware storing key etc.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Something You Are&lt;/strong&gt; : This includes methods which make use of physical human characteristics and biometrics, such as handwritten signatures, fingerprints, voice, retina patterns, and even dynamic keyboarding characteristics.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Entity Authentication is generally used to facilitate access control to a resource or a service, where access privilege is linked to a particular identity. Most common method that is used is password based (belongs to 1st category) and also referred to as weak authentication. The password usually serves a shared secret between user and system. The way information about password is stored on the on the system, and how it is used later to verify the password entered by user determines the possible attacks on the scheme. The Most common way is to store &lt;a href=&quot;https://en.wikipedia.org/wiki/Cryptographic_hash_function&quot;&gt;cryptographic hash&lt;/a&gt; of salted password along with the salt.
The ‘salting of password’ means using adding a fixed size random &lt;a href=&quot;https://en.wikipedia.org/wiki/Cryptographic_nonce&quot;&gt;nonce&lt;/a&gt; to password. Salting makes &lt;a href=&quot;https://en.wikipedia.org/wiki/Dictionary_attack&quot;&gt;dictionary based attacks&lt;/a&gt; harder. What does it mean? Lets say salt is of size 12 bits, so an attacker creating offline dictionary attack would have store all 4096 possible variants of a single guess. If it is remote authentication, passwords are sent in cleartext over a secure channel. If channel is unsecure such schemes are also susceptible to replay attacks (even if you hash and send your password), where adversary learns about hash or cleartext when it is in transit and can use for future authentication. Passwords normally used are sequence of characters with additional minimum requirements placed by server for its strength. But users tend to set passwords with low entropy and hence are easy to guess. Check this &lt;a href=&quot;http://www.jbonneau.com/doc/B12-IEEESP-analyzing_70M_anonymized_passwords.pdf&quot;&gt;paper&lt;/a&gt; from Prof. Bonneau which analyzes millions of passwords used by yahoo users anonymously and proposes several guessing heuristics. 
A better approach is to use passphrases which are easy to remember and have higher entropy than random strings of fixed length.&lt;/p&gt;
&lt;figure&gt;
    &lt;a href=&quot;https://imgs.xkcd.com/comics/password_strength.png&quot;&gt;&lt;img src=&quot;https://imgs.xkcd.com/comics/password_strength.png&quot; /&gt;&lt;/a&gt;
    &lt;figcaption&gt;on password strength&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h2 id=&quot;one-time-passwords&quot;&gt;One Time Passwords&lt;/h2&gt;
&lt;p&gt;One Time Passwords provide timeliness guarantees which help authentication protocols to counter replay attacks. These protocols use one of following time variant parameters.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Random Numbers: used in challenge-response type authentication protocols where one party sends a newly generated nonce to other party and subsequent message are bound to this nonce. This demands for parties to store nonce during one instance of protocol execution&lt;/li&gt;
  &lt;li&gt;Sequence Numbers: This requires parties to maintain state and state is incremented with every execution.&lt;/li&gt;
  &lt;li&gt;Timestamps : Timestamps are included along with messages and messages that are not within a minimum threshold of local clock are discarded. This assume client and server clocks are synchronized and is vulnerable to adversarial resetting of clocks.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In practice, One Time Passwords are used along with other password based (weak authentication) techniques, to confirm User’s ownership of a device (a smartphone). This is most common 2FA (2 Factor) authentication in practice, out of band 2 factor authentication. The one time password generated at server is distributed to user’s registered devices. It could be done by a phone call or SMS. SMS based methods have deprecated and has been discouraged to use by NIST as of June 2016. It is due to ability of SMSs to be intercepted at a large scale.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Time-based_One-time_Password_algorithm&quot;&gt;TOTP&lt;/a&gt; uses both timestamps and sequence numbers, is used in &lt;a href=&quot;https://github.com/google/google-authenticator&quot;&gt;Google Authenticator&lt;/a&gt;, &lt;a href=&quot;https://authy.com/&quot;&gt;Authy&lt;/a&gt; and as part of 2 step verification in most of the web services.&lt;/p&gt;

&lt;p&gt;TOTP allows for users to generate one time passwords locally on their smartphone without network using TOTP applications.  For TOTP, you have one time set up phase and authentications. During set up, user registers with server, and server generates a secret which could be entered on TOTP application on smartphone. After this initial steup, you could just use otps generated on your device to login to server.&lt;/p&gt;

&lt;h2 id=&quot;strong-authentication&quot;&gt;Strong Authentication&lt;/h2&gt;
&lt;p&gt;Cryptographic Challenge Response based protocol typically fall under this category. The general idea is to enable Prover to prove his knowledge of the secret without revealing the secret itself to the verifier during protocol. This is done by providing a response to time variant challenge, this response is depends both on prover’s secret and the challenge. Someone listening on the link between prover and verifier would not be able to use it for subsequent authentication as each time there would be a different challenge.
Challenge response protocols are based on Symmetric key techniques, Public-key techniques and zero knowledge based.
&lt;strong&gt;Symmetric Key&lt;/strong&gt; based techniques rely on secure exchanges of keys and secrecy of keys. There are different implementations based on different kind of time variant parameters as challenges. Usually involved encryption/decryption or keyed hashing of challenge strings.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Public Key&lt;/strong&gt; based techniques involve either decryption of challenge encrypted by public key or digitally signing of challenges to prove knowledge of the private key.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Zero Knowledge Authentication&lt;/strong&gt; based protocols provide Prover ability to prove his knowledge of secret key to verifier without revealing any information about key in the process. These protocols use three steps. In step one, prover commits to a value by sending a commitment to verifier. Verifier sends a challenge to prover. Prover responds to the challenge using the secret and the value he commited in step 1. Finally, verifier check if response is valid by using commitment and Prover’s public information.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://fidoalliance.org/fido2/&quot;&gt;FIDO&lt;/a&gt; publishes standards for web services to use strong authentication. They encourage using public key based challenge response with an additional factor. Google’s security key(tamper resistant usb key device) is compliant with fido standard. The typical flow is&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;User registers on FIDO compliant web service (bank website), which prompts user to insert usb key and press a button.&lt;/li&gt;
  &lt;li&gt;New key pairs are generated locally, private key is on usb key and public key is registered on bank website.&lt;/li&gt;
  &lt;li&gt;Assuming browsers are FIDO Compliant, when accessing the website, a call is made which is same for all browser, which prompts user to use usb key.&lt;/li&gt;
  &lt;li&gt;Response is generated locally using the private key and send to website.&lt;/li&gt;
  &lt;li&gt;User can access the service if response is valid.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Instead of hardware usb key, other second factor devices say smartphone could be used. Keys could be stored locally on device and can be unlocked by binding device to user by using a another layer, say fingerprint scanner (biometrics) to unlock keys locally and send the response to desktop via bluetooth or NFC.&lt;/p&gt;

&lt;p&gt;While this looks good, (No typing/remembering passwords) and safe against passowrd phishing, but is still susceptible to session hijacking (Once the user has logged in).&lt;/p&gt;

&lt;p&gt;Also, another kind of authentication that we havent talked about is called “Continuous Authentication”. It usually works by monitoring user behavior and access patterns during a session, and logging user out if unusual activity is detected. It is very difficult to get it right and contradicts usability if honest users are denied access.&lt;/p&gt;

&lt;p&gt;A very &lt;em&gt;critical vulnerability&lt;/em&gt; in the authentication systems is the recovery mechanism deployed when a honest user loses access to his/her credentials. Here is where tradeoff is made between usability and security. Key recovery mechanism are usually exploited by using &lt;strong&gt;social engineering&lt;/strong&gt; techniques. 
Security in practice follows ‘something is better than nothing’ and try to minimize the attack surface while ensuring usability.&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;Handbook of Applied Cryptography, Alfred J. Manezes, Paul C. van Oorschot, Scott A. Vanstone&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="Authentication" /><category term="Fido" /><category term="Authenticator" /><category term="Authy" /><category term="digital" /><category term="cryptography" /><category term="security" /><summary type="html">How good is MFA?</summary></entry><entry><title type="html">A brief history of e-currencies</title><link href="http://localhost:4000/A-brief-history-of-e-currencies/" rel="alternate" type="text/html" title="A brief history of e-currencies" /><published>2018-07-16T00:00:00-04:00</published><updated>2018-07-16T00:00:00-04:00</updated><id>http://localhost:4000/A-brief-history-of-e-currencies</id><content type="html" xml:base="http://localhost:4000/A-brief-history-of-e-currencies/">&lt;p&gt;This blog post is summary of more detailed chapters about the same topic in the &lt;a href=&quot;https://bitcoinbook.cs.princeton.edu/&quot;&gt;book&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;traditional-financial-systems&quot;&gt;Traditional Financial Systems&lt;/h2&gt;

&lt;h3 id=&quot;barter---cash---credit&quot;&gt;Barter -&amp;gt; Cash -&amp;gt; Credit&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Barter : difficult to make the coordination where everyone finds what he needs based on what he/she is willing to exchange&lt;/li&gt;
  &lt;li&gt;Credit Based System : Goods and Services are received in exchange of favour/promise. Receiving Party has a debt, which it needs to settle in future. No way to quantify the favour. Risk is introduced in the system.&lt;/li&gt;
  &lt;li&gt;Cash Based system : Goods and Services are received in exchange of Cash. Good and Services are quantified using cash. System need to bootstrapped with cash to work.&lt;/li&gt;
  &lt;li&gt;Cash+Credit : Cash is used to quantify debt/favour in credit based systems.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ideas-in-context-of-an-online-p2p-file-sharing-system&quot;&gt;Ideas in context of an online p2p file sharing system&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Addressing “Freeloaders”, downloading but not sharing files&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Mnet_(peer-to-peer_network)&quot;&gt;Mojonation&lt;/a&gt; and Karma, solves using virtual cash or karma, receive some cash on sending some file, and spend that cash upon receiving.&lt;/li&gt;
  &lt;li&gt;These are ancestors of current protocols like BitTorrent, Tahoe-LAFS&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Online payment systems existing today can be grouped into credit and cash based groups. While credit cards transactions account for majority of payments online.
How that works? Well, you send your credit card details to companies like Amazon and they send your details to system which includes and not limited to Banks, processors, credit card companies. Another architecture is similar to paypal, where there is an intermediatory between buyer and seller, buyer sends credit card details to intermediatory which approves the transaction, notifies seller. Intermediatory settles balances with seller at the end of the day. With this architecture you avoid a sending your credit card details to seller which could be a security risk. It could also improve privacy, if you dont have to give your identity to seller. Drawbacks are complexity and that seller and buyer must have same intermediatory. 
Early web of 90s when privacy concerns were high amount users, technologies involving intermediatories were of great interest. Let go through some of the early attempts.&lt;/p&gt;

&lt;h3 id=&quot;firstvirtual-1994&quot;&gt;FirstVirtual 1994&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;First company with virtual office, employees spread across country communicating over internet&lt;/li&gt;
  &lt;li&gt;Similar to paypal but communication using email&lt;/li&gt;
  &lt;li&gt;Buyer and seller both send transaction detail to intermediatory and bills customer and on confirmation, seller is notified&lt;/li&gt;
  &lt;li&gt;90 days to settle consumer dispute&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;set-architecture&quot;&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Secure_Electronic_Transaction&quot;&gt;SET&lt;/a&gt; ARCHITECTURE&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;You send your view of transactions encrypted to Seller&lt;/li&gt;
  &lt;li&gt;Seller Forwards encrypted view with its own view to an intermediatory&lt;/li&gt;
  &lt;li&gt;Intermediatory decrypts your view and verfies if both views are same and approves Transaction&lt;/li&gt;
  &lt;li&gt;Developed by VISA and Mastercard along with Tech giants during that time&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cybercash&quot;&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/CyberCash&quot;&gt;CYBERCASH&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Implemented SET Architecture for credit card processing&lt;/li&gt;
  &lt;li&gt;Also had a digital cash product, CyberCoin for micropayments&lt;/li&gt;
  &lt;li&gt;Upper cap of 10 dollars worth of CyberCoin&lt;/li&gt;
  &lt;li&gt;Was affected by y2k bug - lead to double billing&lt;/li&gt;
  &lt;li&gt;Bankrupt in 2001 and IP was acquired by VeriSign which was resold to Paypal&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Why SET didnt work ?&lt;/p&gt;

&lt;p&gt;Problem of certificates. All users, merchants had to get digital certificates from company like VeriSign which was inconvenient for users.&lt;/p&gt;

&lt;p&gt;Moving on from Credit to Cash. Cash offers additional advantages over credit :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Anonymity : Credit based systems are tied to banks and hence they can track your spendings&lt;/li&gt;
  &lt;li&gt;Offline Transactions&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;e-cash-systems&quot;&gt;E-cash systems&lt;/h2&gt;
&lt;p&gt;Consider this simple physical analogy of a cash system. I issue a piece of paper with my signature on it which says “Bearer of this note can redeem X dollars by presenting it to me”. If people trust that I will keep my promise and my signature is unforgeable, these papers can pass on as bank notes. Now lets assume that people can make perfect copies of these notes and it is difficult to distinguish between original and copy. They can make copies and pass on to different people. This is called double spending problem. 
How do we solve it?
Well we can use unique serial numbers i.e, I write unique number on the paper when I issue it and record it in my ledger. So when someone spends it, the receiver will call me and give the serial number and I will mark it as spent in my ledger. Receiver can later come to me and get new notes with unique serial number in exchange of spent ones. 
Do you see the problem with this? 
We lost the feature that cash offers, anonymity. I can keep track of all the places you are spending your money. Well how do we solve it then?&lt;/p&gt;

&lt;h3 id=&quot;chaums-proposal-and-further-improvements&quot;&gt;Chaum’s Proposal and Further Improvements&lt;/h3&gt;
&lt;p&gt;Chaum’s idea was to use &lt;a href=&quot;http://www.hit.bme.hu/~buttyan/courses/BMEVIHIM219/2009/Chaum.BlindSigForPayment.1982.PDF&quot;&gt;blind signatures&lt;/a&gt;. That is when I issue you note you choose a random number such that I cant see it and I sign it. Choosing a number such a way that it is highly unlikely that it has been picked before. This guarantees Anonymity and prevents double spending.&lt;/p&gt;

&lt;p&gt;Chaum with collaboration with other cryptographers Fiat and Naor came up with offline &lt;a href=&quot;https://link.springer.com/chapter/10.1007/0-387-34799-2_25&quot;&gt;e-cash&lt;/a&gt; scheme. This clever idea revolves around detecting double spending rather than protecting it. Which could be then followed by attempts to recover or punish the perpetrator. If you think about it, it is what traditional finance system do, i.e., if you write someone a personal cheque, they have no guarantee that money is in their account but they can come after you if cheque bounces. If such offline were widely adopted, double spending would be recognized as a crime.
Their scheme worked like this: every digital coin issued to you encodes your identity in way that no one except you can decode it, not even the bank. So every time you want to spend it, recipient ask you to decode a random subset of your encoding and they keep a record of it. This information alone doesnt reveal your identity but if you were to double spend it, both recepients can go to bank with their subset of decodings and bank can put these together to identify you and take actions accordingly. You cannot frame someone as double spender, i.e try to spend coin upon receipt without going to the bank. Because you wont be able to decode random subset upon request when you try to spend it.&lt;/p&gt;

&lt;h3 id=&quot;digicash&quot;&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/DigiCash&quot;&gt;Digicash&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;It is company that came out of Chaum-Fiat-Naor scheme founded by Chaum in 1989. The cash in the system was Ecash. It works the following way&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Clients are anonymous but Merchant’s aren’t. Merchants have to return coin to the bank as soon as they receive them.&lt;/li&gt;
  &lt;li&gt;Coins can’t be split, so banks issue different kind of denominations, for you to pay for exact amount  of a transactions.&lt;/li&gt;
  &lt;li&gt;You click on payment link, it takes you to digicash website which creates a reverse connection to your computer and starts digicash software on it. you apporve the transaction and send the money.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;why did it fail ?&lt;/p&gt;

&lt;p&gt;Banks and merchants didnt adopt it. since there werent many merchants that accepted e-cash, users didnt want it either. It also didnt support user-user transactions.&lt;/p&gt;

&lt;p&gt;Digicash also experimented with tamper resistant hardware to prevent double spending. Sort of chip card and a device which keep track of your balance which decreases when you spend and increases when load it with money. This counter was was very difficult to tamper with physically.&lt;/p&gt;

&lt;h3 id=&quot;mondex-system&quot;&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Mondex&quot;&gt;Mondex&lt;/a&gt; system&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;A smart card and a Wallet unit.&lt;/li&gt;
  &lt;li&gt;Either could be loaded with cash.&lt;/li&gt;
  &lt;li&gt;User-User swap happened using wallet, put money into wallet by insertng card and receiver put their card in the wallet and load money onto card.&lt;/li&gt;
  &lt;li&gt;Anonymous way to exchange digital cash.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Issues with Mondex : slow and clunky, and retailer hated having separate payment terminals&lt;/p&gt;

&lt;p&gt;However, the smart card technology prevailed. Not for preventing double spending but to be used as authentication mechanism. That is you know the pin associated with your account.&lt;/p&gt;

&lt;h2 id=&quot;minting-money-in-digital-systems&quot;&gt;Minting Money in digital systems&lt;/h2&gt;
&lt;p&gt;To create a free-floating digital currency which is likely to acquire real value, you need something which is scarce by design. This is why gold/diamonds have been used as a backing for money. 
In digital ecosystems, one way to achieve scarcity is by requiring to solve a computational puzzle that takes some time to crack to mint digital money.&lt;/p&gt;

&lt;h3 id=&quot;dwork-and-naor-scheme-1992&quot;&gt;&lt;a href=&quot;https://dl.acm.org/citation.cfm?id=705669&quot;&gt;Dwork and Naor Scheme&lt;/a&gt; (1992)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;solution to combat email spams&lt;/li&gt;
  &lt;li&gt;reuqires you to solve mini computational puzzles every time your sending an email&lt;/li&gt;
  &lt;li&gt;Heavy cost for spammer who is try to send million emails&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;hashcash-1997&quot;&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Hashcash&quot;&gt;Hashcash&lt;/a&gt; (1997)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Proposed by Adam Back&lt;/li&gt;
  &lt;li&gt;Puzzles specific to email: based on sender, receiver and content and time which makes it impossible for spammers to reuse puzzle solutions&lt;/li&gt;
  &lt;li&gt;Puzzle independence&lt;/li&gt;
  &lt;li&gt;difficulty adjustment by recipients&lt;/li&gt;
  &lt;li&gt;Bitcoin uses similar puzzles with minor variation&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Why Hashcash didnt catch on ?&lt;/p&gt;

&lt;p&gt;Email spams arent that big of a problem. Good spam filters in place today.&lt;/p&gt;

&lt;h2 id=&quot;secure-timestamping&quot;&gt;Secure Timestamping&lt;/h2&gt;
&lt;p&gt;The goal of timestamping is to give an approximate idea of when a document came into existense. It could convey the order in which they are created. The security property ensures the timestamps cant be changed after.
These were ideas that might have lead up to blockchain, ledger in which transaction are securely recorded.&lt;/p&gt;

&lt;h3 id=&quot;haber-and-stornettas-scheme&quot;&gt;Haber and Stornetta’s &lt;a href=&quot;https://www.anf.es/pdf/Haber_Stornetta.pdf&quot;&gt;scheme&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Timestamping service which receives the document to timestamp&lt;/li&gt;
  &lt;li&gt;Service creates a certificate by signing the document with current time and a link/pointer  to previous document.&lt;/li&gt;
  &lt;li&gt;Each document ensures integrity of the contents of Next one,&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Later proposals improve on efficiency by grouping documents in blocks and linking the blocks together in a chain. Within each block, link documents in a tree like structure. This data structure forms skeleton of Bitcoin’s blockchain.&lt;/p&gt;

&lt;h2 id=&quot;combining-computational-puzzles-and-secure-timestamping&quot;&gt;Combining computational puzzles and secure timestamping&lt;/h2&gt;

&lt;h3 id=&quot;b-money&quot;&gt;&lt;a href=&quot;http://www.weidai.com/bmoney.txt&quot;&gt;B-money&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Proposed by Wei Dai in 1998&lt;/li&gt;
  &lt;li&gt;Money is minted using hashcash like puzzles&lt;/li&gt;
  &lt;li&gt;Solutions include solution to previous solution i.e, new coin is linked to previously minted coin&lt;/li&gt;
  &lt;li&gt;p2p system with every node having its own ledger&lt;/li&gt;
  &lt;li&gt;Solution to puzzles is propogated and everyone increment solver’s balance in their ledger&lt;/li&gt;
  &lt;li&gt;Similarly transactions are propogated&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;bitgold&quot;&gt;&lt;a href=&quot;&quot;&gt;Bitgold&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Proposed by Nick Szabo in series of blog posts&lt;/li&gt;
  &lt;li&gt;Similar to b-money&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Both B-money and Bitgold doesnt reveal in detail about how to solve issues like resolving disagreements with ledger.&lt;/p&gt;

&lt;p&gt;In Next series of blogs, I will write about cyptographic methods, consensus algorithms used in bitcoin and other altcoins. I also plan to write some dev-friendly blog-posts for getting started with smart-contract on various platforms.&lt;/p&gt;</content><author><name></name></author><category term="cryptocurrencies" /><category term="bitcoin" /><category term="history" /><category term="bitcoinbook.cs.princeton.edu" /><summary type="html">Digital cash system attempts before bitcoin.</summary></entry></feed>